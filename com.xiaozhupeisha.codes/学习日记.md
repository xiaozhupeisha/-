[# 序言

# 2022-08-18 21:21
### leetcode第 1 题
数组操作需要考虑边界值，特别是循环里面既判断左也判断右，混合continue、break的

### leetcode第 2 题
要输出计算出的新的链表的值，一般情况下来说，会新建一个新的虚拟节点，然后初始化一个指针，后续产生新的节点时候，则是跟着指针，也就是指针.next=新的节点1，指向完了之后需要记得将指针向后移动一格，也就是指针.next=新的节点2。最后完整的链表则是去除虚拟节点后的整个链表，也就是虚拟节点.next，返回一个头就可以了，虚拟节点后面自然跟着所有的链表的节点。

# 2022-08-20 09:47
### leetcode第 3 题
滑动窗口的灵魂是左闭右开，设置一个目标值，随着滑动窗口的移动，更新目标的值，比如说无重复的最长子串

### leetcode第 4 题
这道题是自己想的办法，使用2个指针分别扫描2个升序数组，比较大小移动2个指针，最终合并数组，参考的双指针算法

# 2022-08-21 08:41
### leetcode第 5 题
回文子串的定义：正读和反读都相同的字符序列为“回文”
<br>最长回文子串的关键是双指针扩散，找到以 s[i] 为中心的回文串。判断回文串的方法是找到距离left最远的和left相等的right，找到的同时left可以向左移动，right向右移动
<br>找回文串的关键技巧是传入两个指针 l 和 r 向两边扩散，因为这样实现可以同时处理回文串长度为奇数和偶数的情况。

### leetcode第 6 题
暂时没看懂，参考：https://zhuanlan.zhihu.com/p/79915327

### leetcode第 7 题
翻转整数的关键是%和/的运用，同时需要考虑到int的范围2147483647

### leetcode第 8 题
不属于常规Java算法题，暂时略过

### leetcode第 9 题
使用双指针，一左一右主意对比是否回文

### leetcode第 10 题
正则匹配使用到的动态规划过于复杂，后面继续研究

### leetcode第 11 题
类似于按横纵坐标计算容器最大水的情况，需要注意的一个是接水的容器是规则的，不倾斜，另一个就是使用双指针解决问题时，移动短边，因为移动长边是没有意义的，只会让容器越来越小，所以使用双指针从外向里计算一遍，更新最多大的值。

### leetcode第 12 题
从大到小，从左到右。同时每个数字本身也可能拆分，比如600=500+100，永远拆分一次，每个values只用一次，这样算起来的话。743 = 500 + 100 + 100 + 40 +3。内部记得使用while的，比如说80，那么就要计算2次，40+40

### leetcode第 13 题
罗马数字转换成数字的核心则是多算一位，即查询当前指针的下一个字母，如果发现是减的写法，则用后面一位的值减去这一位的值，然后索引额外加1，一次性处理了2个字母

# 2022-08-22 21:51
### leetcode第 14 题
计算最长公共前缀的核心在于数组的越界判断，比如数组只有一个值的情况，数组多个值里面有空或者都为空的情况

### leetcode第 15 题
2/3/4....N数之和，通过数组双指针和递归解决问题，一套公式秒杀所有N数之和的问题，这里的关键点在于递归，栈的最低层简化为2数之和，从而一层层出栈。递归方法的入参为：需要计算的数组、需要找出N个数值、当前的索引、目标值
<br>一个方法团灭 NSUM 问题：https://labuladong.github.io/algo/1/15/

# 2022-08-24 10:10
### leetcode第 16 题
N数之和是重点，由此可以延伸出最接近的三数之和，最接近的三数之和的核心是，从左到右遍历，以0 <= i < nums.length() - 2开始，每次遍历都找出i + 1 ~ nums.length()之间，距离目标值-当前i值最小的2个数字的值。再加上当前i的值，然后每次循环都更新这个最小的值
<br>一个方法团灭 NSUM 问题：https://labuladong.github.io/algo/1/15/

### leetcode第 17 题
电话号码的排列组合，使用回溯算法，其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，组合问题本质上就是遍历一棵回溯树，套用回溯算法代码框架即可。
<br>参考图片：https://labuladong.github.io/algo/images/backtracking/1.jpg
<br>回溯算法解题套路框架：https://labuladong.github.io/algo/1/8/
<br>回溯算法其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」

### leetcode第 18 题
参考leetcode15题，2/3/4....N数之和，通过数组双指针和递归解决问题，一套公式秒杀所有N数之和的问题，这里的关键点在于递归，栈的最低层简化为2数之和，从而一层层出栈。递归方法的入参为：需要计算的数组、需要找出N个数值、当前的索引、目标值
<br>一个方法团灭 NSUM 问题：https://labuladong.github.io/algo/1/15/

### leetcode第 19 题
要求一个链表的倒数第N个节点，需要用到快慢双指针方法，因为链表的长度的如果不遍历一遍的话是不知道的，通过N和双指针的快慢移动，能一次找到倒数第N个节点，它的逻辑是这样的，快指针先向后移动N个，慢指针不动，随后双指针同时移动，一直等到快指针到底，也就是NULL了，则这时候慢指针则倒了n-k的位置，即倒数第N个节点
<br>注意：快指针应该先走N+1，快慢一起走的时候慢指针先赋值，最终设置慢指针的下个节点等于原本的下下个节点，最终返回dummy的next节点，则是整个链表去除了倒数第N个节点

### leetcode第 20 题
判断括号是否闭合的关键是使用栈的数据结构，如果是左边的符号，则压入栈，如果是右边符号，则判断栈顶元素是否和他匹配，随后弹出右边符号
<br>注意：Stack.pop是弹出，peek是取值但是不弹出

# 2022-08-25 14:57
### leetcode第 21 题
合并2个有序链表的关键还是在于双指针和链表得的处理，老生常谈了。由于题目没有说明2个链表是一样的长度，而他们又经过排序了，所以只遍历到最短的长度，剩下的安心叠加到结果节点后面就行了
<br>注意：老规矩还是初始化一个虚拟节点dummy，然后用dummy.next去接住下面生成的真正的节点的头

### leetcode第 22 题
生成括号的问题使用回溯算法来题解，主要是先抽象出回溯的树，然后定义递归的参数，以及是否需要撤销选择，第17题就不需要撤销，长度到了就弹出了。括号问题的递归函数的参数定义为：左边括号剩余个数+右边括号剩余个数+当前树的路径生成的括号字符串
<br>递归函数内判断撤销选择的条件为：左边括号已经用掉的数量大于右边括号用掉的数量、没有剩余的括号数量了
<br>递归函数内压入栈的操作为：先压入左边括号，再压入右边括号，和函数对应，因为左边括号永远比右边括号多

### leetcode第 23 题
N多个链表的合并排序，这里的关键点在于使用优先级队列，也就是最小堆，将N个链表比如a1,b1,c1的头节点首先全部放入队列，随后定义一个虚拟节点，第一次判断得出他等于队列最小的b1，随后将b1拉到dummy的next，随后b1空出来了，如果还有b2，则填补上去，再次进入判断
<br>注意：dummy节点每次都要推进，即p=p.next，相当于初始化
<br>PriorityQueue Java（优先队列）参考文档：https://zhuanlan.zhihu.com/p/491698105

# 2022-08-26 05:43
### leetcode第 24 题
2个一组交换链表中的节点，核心还是在于递归，第1，2个节点排除在外等待递归出栈，最终结果是1指向1和2后面交换完成的子链表，2指向1。终止条件就是无法交换，为空，跳出递归
<br>疑问：这是碳基生物能想出来的逻辑？

### leetcode第 25 题
K个一组交换链表中的节点，核心还是在于递归，由小及大，终止条件是最后一组链表的长度小于k。先反转以 head 开头的 k 个元素。然后将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。最后将上述两个过程的结果连接起来。
<br>一段n长度的链表的翻转参考：https://labuladong.github.io/algo/2/19/20/
<br>一段n长度的a-b的链表翻转：定义pre、cu、next。循环开始的标志是cu还在a-b链表之内，结束的标志是cu到了末尾了。翻转的逻辑是：next = cu.next,cu.next=pre,pre=cu,cu=next.最后返回pre

### leetcode第 26 题
升序排列 的数组 nums原地修改值，因为是升序排序过，所以核心还是在于快慢指针。快指针走在前，慢指针不动，如果快指针当前的值不等于慢指针所在位置的值，则把当前慢指针所在位置的值设置为快指针的值，然后慢指针移动，快指针继续向右。

### leetcode第 27 题
升序排列 的数组 nums原地修改值，因为是升序排序过，所以核心还是在于快慢指针。快指针走在前，慢指针不动，如果快指针当前的值不等于要删除的值，则把当前慢指针所在位置的值设置为快指针的值，然后慢指针移动，快指针继续向右。
<br>注意：27题和26题不一样，26题是先移动慢指针，再给慢指针赋值，27题是先赋值，再移动

### leetcode第 28 题
动态规划尚未学习到，暂时使用indexOf。实际上可以使用滑动窗口(l,r)，l和r分别代表子串的左右边界，初始化时候l在第一个位置，r在字符串的第r位置，如果不相等，则移动窗口两边指针同时向右，一直到匹配或者结束
<br>有限状态机之 KMP 字符匹配算法：https://labuladong.github.io/algo/3/28/97/

# 2022-08-28 08:02
### leetcode第 29 题
两数相除，不能用乘法和除法。
<br>方法一：定义被除数i，使用递归，将当前累计的值和总值传入，如果剩余值小于被除数，则结束

### leetcode第 30 题
查找子串的方法还是用滑动窗口，如果题目要求是多个单词，则用一个滑动窗口放多个单词，多个单词的顺序如果可变的话，则使用哈希值来判断。

### leetcode第 31 题
我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
<br>我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
<br>1.在尽可能靠右的低位进行交换，需要从后向前查找
<br>2.将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
<br>3.将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列
<br>代码总结下来就三步骤：
<br>1.使用指针i，从倒数第二位开始向前遍历，看一下相邻2个位置的数字大小，找到就停止
<br>2.使用指针j，从倒数第一位开始向前遍历，看一下i和j个位置的数字大小，如果i>j，则将i和j调换位置
<br>3.翻转i后面所有的值，得到下一个排列
<br>备注：数组调换位置的话，定义一个临时的值tmp等于nums[a]，然后nums[a] = nums[b], 最后nums[b] = tmp

# 2022-08-29 09:15
### leetcode第 32 题
单调栈解题模板秒杀三道算法题：https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487246&idx=1&sn=4a514020ce9dc8777e2d1d503188b62b&chksm=9bd7f106aca078108102fe76799983ee8ea3bd759508e6dbfe87bc9da6edbeb8b8dd73deb0d7&scene=178&cur_album_id=2121993002939219969#rd
<br>Stack.peek()，peek()函数返回栈顶的元素，但不弹出该栈顶元素。
<br>Stack.pop()，pop()函数返回栈顶的元素，并且将该栈顶元素出栈。
得到一个字符串的最长有效括号的核心代码：Stack<Integer> stk = new Stack<>();int[] dp = new int[s.length() + 1];
<br>碰到左边括号，则stk.push(i);dp[i + 1] = 0;
<br>碰到右边括号且没匹配到栈顶元素，则dp[i + 1] = 0;
<br>碰到右边括号且匹配到了栈顶元素，则int leftIndex = stk.pop();int len = 1 + i - leftIndex + dp[leftIndex]; dp[i + 1] = len;

### leetcode第 33 题
搜索旋转排列后的数组里面是否包含值，直接使用二分查找，分为2段。从2头开始查找，nums[i]和nums[numsSize - i - 1]是否等于目标值
<br>二分算法相关文档：
<br>二分查找算法详解：https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484507&idx=1&sn=36b8808fb8fac0e1906493347d3c96e6&chksm=9bd7fa53aca0734531ec9f37127c0f371344e1690918888dfb1cfdf043c40c0b43d1121e5851&scene=21#wechat_redirect
<br>我写了一个套路，助你随心所欲运用二分搜索:https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247491336&idx=1&sn=dbcbb07b05ebc7889f944d54d2acebd4&chksm=9bd7e100aca0681623458e773606cdb9287a342ceebbc3263cb3f994eb8911219887177618df&scene=178&cur_album_id=2120601117519675393#rd

### leetcode第 34 题
二分搜索的难点就在于如何搜索左侧边界和右侧边界，本题根据目标值 target找出给定目标值在数组中的开始位置和结束位置。找开始位置时候应该是左侧边界，找结束位置的时候应该是右侧边界。
<br>找左侧开始位置时候：if nums[mid] == target，则收缩右侧边界 right = mid - 1;
<br>找右侧开始位置时候：if nums[mid] == target，则收缩左侧边界 left = mid + 1;

### leetcode第 35 题
搜索左侧边界:给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
<br>int l = 0; int r = length; int mid = l + (r - l) / 2;
<br>if (nums[mid] == target) r = mid;
<br>else if (nums[mid] < target) l = mid + 1;
<br>else if (nums[mid] > target) r = mid;

# 2022-08-30 09:52
### leetcode第 36 题
针对于一整行或者一整列中某个数字出现的次数，则需要用到二维数组，[行/列][数字值] = 这一行/列中数字值出现的次数，>1则不符合题目要求
<br>二维数组的定义格式：元素的数据类型[][] 数组的名字 = new 元素的数据类型[二维数组的长度][一维数组的长度];
<br>int[][] arr = new int[9][9];
<br>一维数组:9个 ，每个一维数组9个元素，在这里就是9行/列，每一行/列都有9个坐标值，用这些值来维护这个值在一整行/列中出现的次数，比方如果数字5在第一行出现了2次则，i[1][5-1]=2，不属于数独的情况
<br>针对于9宫格中某个数字出现的次数，则需要用到三维数组，[行][列][数字值] = 这一行+列的九宫格中数字值出现的次数，>1则不符合题目要求
<br>int[9][9]初始化出来的值是这样的：9x9的一个二维数组，每个里面初始化的值大都是0

### leetcode第 37 题
暂时没看懂，放一下
<br>为 num 只要满足关系 !row[i][num] && !col[j][num] && !block[blockIndex][num] 就可以在 board[i][j] 处填上 num。很显然，num 的取值不是唯一的，所以需要先假定 board[i][j] = num，之后再找寻下一个空位置，以上方同样的关系的进行数独求解。假设在 board[i][j] 处填上 num 使得数独无解，就需要进行回溯，消除 num 在 row[i]，col[j]，block[i / 3 * 3 + j / 3] 中的标记，为 board[i][j] 赋予除 num 的另一个值，再次对数独进行递归求解

### leetcode第 38 题
外观数列问题，没什么好说的，也可以用双指针滑动窗口来解决，获取到一个数字重复的部分，处理完就滑动到下一个重复的部分。最终拼接为下一个字符串

# 2022-08-31 08:18
### 今天主要学习回溯算法
回溯算法基础：https://labuladong.github.io/algo/4/31/105/
<br>回溯算法秒杀所有排列/组合/子集问题 ：https://labuladong.github.io/algo/4/31/107/
解决一个回溯问题，实际上就是一个决策树的遍历过程，站在回溯树的一个节点上，你只需要思考 3 个问题：
<br>1、路径：也就是已经做出的选择。
<br>2、选择列表：也就是你当前可以做的选择。
<br>3、结束条件：也就是到达决策树底层，无法再做选择的条件。
* def backtrack(路径, 选择列表):
* if 满足结束条件: result.add(路径)；return
* for 选择 in 选择列表: 做选择；backtrack(路径, 选择列表)；撤销选择

### leetcode第 39 题
子集组合元素无重可复选的组合总和问题
<br>转化为一个标准的回溯树，但是【每个元素可以被重复的使用】。参考图片：https://labuladong.github.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/10.jpeg
<br>输入：candidates =[2,3,6,7], target = 7
<br>输出：[[2,2,3],[7]]
* 定义变量用于存储最终的子集列表：List<List<Integer>> res = new LinkedList<>();
* 定义变量用于记录回溯树上子集路径：LinkedList<Integer> track = new LinkedList<>();
* 定义变量用于记录回溯树上子集的和：int trackSum = 0;
* 定义backtrack第一个参数：int[] nums，它是一个整数数组
* 定义backtrack第二个参数：start，它由0开始、nums.length结束，并且要求的结果是子集，并且可重复
* 定义backtrack第三个参数：target，这个是目标值，用来递归方法内结束或者终止动作
* 定义第一个base-case：trackSum == target，代表找到目标的和了，这个时候需要将子集track放到结果res里面
* 定义第二个base-case：trackSum > target，不符合题目要求，停止遍历
* 回溯算法for循环的定义：定义i=start;i< nums.length;i++，代表树有几层，每层都要进行回溯
* 回溯算法for循环内如何做选择：trackSum += nums[i]
* 回溯算法for循环内如何做选择：track.add(nums[i])
* 回溯算法for循环内下一次递归的传参：trackback(nums, i, target)
* 回溯算法for循环内如何撤销回溯：trackSum -= nums[i]
* 回溯算法for循环内如何撤销回溯：track.removeLast()

### leetcode第 40 题
本题目和39题的区别是：candidates 中的每个数字在每个组合中只能使用[一次]，所以这段代码和之前标准的子集问题的代码几乎相同，就是添加了排序和剪枝的逻辑。
<br>输入：candidates =[2,2,3,4,5], target = 7
<br>输出：[[2,5],[3,4]]
* 开始回溯算法之前，将数组进行排序，这样可以将相邻相等的数字贴在一起，方面回溯循环内的跳过动作
* 回溯算法for循环中，如果nums[i] == nums[i+1]，则continue
* 回溯算法for循环中，传递给下一次递归树时，索引值i不再是给i本身了，应该给i+1

# 2022-09-01 09:11
### leetcode第 41 题
题目意义不大，具体参考：https://leetcode.cn/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/

### leetcode第 42 题
带柱子的接雨水的变种问题，使用双指针来解决问题， 对于每一个柱子接的水，那么它能接的水=min(左右两边最高柱子）-当前柱子高度，这个公式。具体分为
* 定义left指针初始化=1(因为0的话左边没值，没意义)，从左边跑到右边，每次都计算nums[left,left-1]直接最大的值，放入left_num[]
* 定义right指针初始化=n-2(因为n-1的话右边没值，没意义)，从右边跑到左边，每次都计算nums[right,right+1]直接最大的值，放入right_num[]
* 从左到右开始遍历，每个i都去left_num[]和right_num[]里面取值，并且取两者较小的一个，并且减去i的高度，这个比较重要
* l_nums[i] = Math.max(height[i], l_nums[i - 1]);
* r_nums[i] = Math.max(height[i], r_nums[i + 1]);
* result += Math.min(l_nums[i], r_nums[i]) - height[i];

# 2022-09-02 08:52
### leetcode第 43 题
两个字符串相乘，关键在于
* m长度和n长度的字符串，相乘最大的长度为[m+n]
* int index1 = i + j, index2 = i + j + 1; //m[i]和n[j]的乘机在结果中处于[i+j][i+j+1]的位置
* int sum = result[index2] + r; //从p2开始，先把乘积加上当前的值
* result[index2] = sum % 10; //求一下余数，比如5+12=17，那么这里就应该是17%10=7
* result[index1] += sum / 10; //求一下除，比如5+12=17，那么这里就应该是17/10=1

### leetcode第 44 题
动态规划，暂时放一放

### leetcode第 45 题
跳跃游戏的思路：贪心算法，用 i 和 end 标记了可以选择的跳跃步数，farthest 标记了所有选择 [i..end] 中能够跳到的最远距离，jumps 记录跳跃次数。
* 先跳出去，累计1次跳跃次数，再从当前位置i跳出去的i...i.end中，选择一个能跳出去最远的，这是第一次跳跃
* 第一次跳跃之后，处在了跳跃后能跳最远的地方，以此类推：
* 先跳出去，累计1次跳跃次数，再从当前位置i跳出去的i...i.end中，选择一个能跳出去最远的，这是第二次跳跃
* 第二次跳跃之后，处在了跳跃后能跳最远的地方，以此类推...
* fathest = Math.max(fathest, nums[i] + i);
* if(end == i) end = fathest;jump++;

### leetcode第 46 题
排列（元素无重不可复选）问题：给定一个不含重复数字的数组 nums，返回其所有可能的全排列。
<br>输入：candidates =[1,2,3]
<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
* 定义变量用于存储最终的集合列表：List<List<Integer>> res = new LinkedList<>();
* 定义变量用于记录回溯树上集合路径：LinkedList<Integer> track = new LinkedList<>();
* 定义变量用于记录回溯树上元素是否使用过：boolean[] hasUsed;
* 定义backtrack参数：int[] nums，它是一个整数数组
* 定义base-case：track.size() == nums.length，代表找到目标排列了，这个时候需要将子集track放到结果res里面
* 回溯算法for循环的定义：定义i=start;i< nums.length;i++，代表树有几层，每层都要进行回溯
* 回溯算法for循环内如何做剪枝：if (hasUsed[i]) continue;
* 回溯算法for循环内如何做选择：track.add(nums[i]);
* 回溯算法for循环内如何做选择：hasUsed[i] = true;
* 回溯算法for循环内下一次递归的传参：trackback(nums);
* 回溯算法for循环内如何撤销回溯：track.removeLast();
* 回溯算法for循环内如何撤销回溯：hasUsed[i] = false;

### leetcode第 47 题
排列（元素可重不可复选）问题：给你输入一个可包含重复数字的序列nums，返回其所有可能的全排列。
<br>输入：candidates =[1,2,2]
<br>输出：[[1,2,2],[2,1,2],[2,2,1]]
* 数组进行一次排序:Arrays.sort(nums);
* 相邻节点值相同并且已经放进去过，则不加入结果：i > 0 && (nums[i] == nums[i - 1]) && hasUsed[i - 1]

### leetcode第 48 题
旋转nxn的二维矩阵，思路比较简单，核心就是先对折再reverse每个数组，就能得到最终解
* 对折的方法是定义指针i=0~length-1，定义指针j=i,j++,j<length，这样就可以将(1,2)(1,3)(1,4)和(2,1)(3,1)(4,1)进行对折了
* 对折后需要反转，反转的话定义i=0,j=length-1,arr[i]=arr[j]
