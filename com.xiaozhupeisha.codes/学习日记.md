# 2022-08-18 21:21

### leetcode第 1 题
数组操作需要考虑边界值，特别是循环里面既判断左也判断右，混合continue、break的

### leetcode第 2 题
要输出计算出的新的链表的值，一般情况下来说，会新建一个新的虚拟节点，然后初始化一个指针，后续产生新的节点时候，则是跟着指针，也就是指针.next=新的节点1，指向完了之后需要记得将指针向后移动一格，也就是指针.next=新的节点2。最后完整的链表则是去除虚拟节点后的整个链表，也就是虚拟节点.next，返回一个头就可以了，虚拟节点后面自然跟着所有的链表的节点。

# 2022-08-20 09:47
### leetcode第 3 题
滑动窗口的灵魂是左闭右开，设置一个目标值，随着滑动窗口的移动，更新目标的值，比如说无重复的最长子串

### leetcode第 4 题
这道题是自己想的办法，使用2个指针分别扫描2个升序数组，比较大小移动2个指针，最终合并数组，参考的双指针算法

# 2022-08-21 08:41
### leetcode第 5 题
回文子串的定义：正读和反读都相同的字符序列为“回文”
<br>最长回文子串的关键是双指针扩散，找到以 s[i] 为中心的回文串。判断回文串的方法是找到距离left最远的和left相等的right，找到的同时left可以向左移动，right向右移动
<br>找回文串的关键技巧是传入两个指针 l 和 r 向两边扩散，因为这样实现可以同时处理回文串长度为奇数和偶数的情况。

### leetcode第 6 题
暂时没看懂，参考：https://zhuanlan.zhihu.com/p/79915327

### leetcode第 7 题
翻转整数的关键是%和/的运用，同时需要考虑到int的范围2147483647

### leetcode第 8 题
不属于常规Java算法题，暂时略过

### leetcode第 9 题
使用双指针，一左一右主意对比是否回文

### leetcode第 10 题
正则匹配使用到的动态规划过于复杂，后面继续研究

### leetcode第 11 题
类似于按横纵坐标计算容器最大水的情况，需要注意的一个是接水的容器是规则的，不倾斜，另一个就是使用双指针解决问题时，移动短边，因为移动长边是没有意义的，只会让容器越来越小，所以使用双指针从外向里计算一遍，更新最多大的值。

### leetcode第 12 题
从大到小，从左到右。同时每个数字本身也可能拆分，比如600=500+100，永远拆分一次，每个values只用一次，这样算起来的话。743 = 500 + 100 + 100 + 40 +3。内部记得使用while的，比如说80，那么就要计算2次，40+40

### leetcode第 13 题
罗马数字转换成数字的核心则是多算一位，即查询当前指针的下一个字母，如果发现是减的写法，则用后面一位的值减去这一位的值，然后索引额外加1，一次性处理了2个字母

# 2022-08-22 21:51
### leetcode第 14 题
计算最长公共前缀的核心在于数组的越界判断，比如数组只有一个值的情况，数组多个值里面有空或者都为空的情况

### leetcode第 15 题
2/3/4....N数之和，通过数组双指针和递归解决问题，一套公式秒杀所有N数之和的问题，这里的关键点在于递归，栈的最低层简化为2数之和，从而一层层出栈。递归方法的入参为：需要计算的数组、需要找出N个数值、当前的索引、目标值
<br>一个方法团灭 NSUM 问题：https://labuladong.github.io/algo/1/15/

# 2022-08-24 10:10
### leetcode第 16 题
N数之和是重点，由此可以延伸出最接近的三数之和，最接近的三数之和的核心是，从左到右遍历，以0 <= i < nums.length() - 2开始，每次遍历都找出i + 1 ~ nums.length()之间，距离目标值-当前i值最小的2个数字的值。再加上当前i的值，然后每次循环都更新这个最小的值
<br>一个方法团灭 NSUM 问题：https://labuladong.github.io/algo/1/15/

### leetcode第 17 题
电话号码的排列组合，使用回溯算法，其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，组合问题本质上就是遍历一棵回溯树，套用回溯算法代码框架即可。
<br>参考图片：https://labuladong.github.io/algo/images/backtracking/1.jpg
<br>回溯算法解题套路框架：https://labuladong.github.io/algo/1/8/

### leetcode第 18 题
参考leetcode15题，2/3/4....N数之和，通过数组双指针和递归解决问题，一套公式秒杀所有N数之和的问题，这里的关键点在于递归，栈的最低层简化为2数之和，从而一层层出栈。递归方法的入参为：需要计算的数组、需要找出N个数值、当前的索引、目标值
<br>一个方法团灭 NSUM 问题：https://labuladong.github.io/algo/1/15/

### leetcode第 19 题
要求一个链表的倒数第N个节点，需要用到快慢双指针方法，因为链表的长度的如果不遍历一遍的话是不知道的，通过N和双指针的快慢移动，能一次找到倒数第N个节点，它的逻辑是这样的，快指针先向后移动N个，慢指针不动，随后双指针同时移动，一直等到快指针到底，也就是NULL了，则这时候慢指针则倒了n-k的位置，即倒数第N个节点
<br>注意：快指针应该先走N+1，快慢一起走的时候慢指针先赋值，最终设置慢指针的下个节点等于原本的下下个节点，最终返回dummy的next节点，则是整个链表去除了倒数第N个节点

### leetcode第 20 题
判断括号是否闭合的关键是使用栈的数据结构，如果是左边的符号，则压入栈，如果是右边符号，则判断栈顶元素是否和他匹配，随后弹出右边符号
<br>注意：Stack.pop是弹出，peek是取值但是不弹出

# 2022-08-25 14:57
### leetcode第 21 题
合并2个有序链表的关键还是在于双指针和链表得的处理，老生常谈了。由于题目没有说明2个链表是一样的长度，而他们又经过排序了，所以只遍历到最短的长度，剩下的安心叠加到结果节点后面就行了
<br>注意：老规矩还是初始化一个虚拟节点dummy，然后用dummy.next去接住下面生成的真正的节点的头

### leetcode第 22 题
生成括号的问题使用回溯算法来题解，主要是先抽象出回溯的树，然后定义递归的参数，以及是否需要撤销选择，第17题就不需要撤销，长度到了就弹出了。括号问题的递归函数的参数定义为：左边括号剩余个数+右边括号剩余个数+当前树的路径生成的括号字符串
<br>递归函数内判断撤销选择的条件为：左边括号已经用掉的数量大于右边括号用掉的数量、没有剩余的括号数量了
<br>递归函数内压入栈的操作为：先压入左边括号，再压入右边括号，和函数对应，因为左边括号永远比右边括号多

### leetcode第 23 题
N多个链表的合并排序，这里的关键点在于使用优先级队列，也就是最小堆，将N个链表比如a1,b1,c1的头节点首先全部放入队列，随后定义一个虚拟节点，第一次判断得出他等于队列最小的b1，随后将b1拉到dummy的next，随后b1空出来了，如果还有b2，则填补上去，再次进入判断
<br>注意：dummy节点每次都要推进，即p=p.next，相当于初始化
<br>PriorityQueue Java（优先队列）参考文档：https://zhuanlan.zhihu.com/p/491698105

# 2022-08-26 05:43
### leetcode第 24 题
2个一组交换链表中的节点，核心还是在于递归，第1，2个节点排除在外等待递归出栈，最终结果是1指向1和2后面交换完成的子链表，2指向1。终止条件就是无法交换，为空，跳出递归
<br>疑问：这是碳基生物能想出来的逻辑？

### leetcode第 25 题
K个一组交换链表中的节点，核心还是在于递归，由小及大，终止条件是最后一组链表的长度小于k。先反转以 head 开头的 k 个元素。然后将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。最后将上述两个过程的结果连接起来。
<br>一段n长度的链表的翻转参考：https://labuladong.github.io/algo/2/19/20/
<br>一段n长度的a-b的链表翻转：定义pre、cu、next。循环开始的标志是cu还在a-b链表之内，结束的标志是cu到了末尾了。翻转的逻辑是：next = cu.next,cu.next=pre,pre=cu,cu=next.最后返回pre
