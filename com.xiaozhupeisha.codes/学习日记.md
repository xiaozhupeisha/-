# 序言

# 2022-08-18 21:21
### leetcode第 1 题
数组操作需要考虑边界值，特别是循环里面既判断左也判断右，混合continue、break的

### leetcode第 2 题
要输出计算出的新的链表的值，一般情况下来说，会新建一个新的虚拟节点，然后初始化一个指针，后续产生新的节点时候，则是跟着指针，也就是指针.next=新的节点1，指向完了之后需要记得将指针向后移动一格，也就是指针.next=新的节点2。最后完整的链表则是去除虚拟节点后的整个链表，也就是虚拟节点.next，返回一个头就可以了，虚拟节点后面自然跟着所有的链表的节点。

# 2022-08-20 09:47
### leetcode第 3 题
滑动窗口的灵魂是左闭右开，设置一个目标值，随着滑动窗口的移动，更新目标的值，比如说无重复的最长子串

### leetcode第 4 题
这道题是自己想的办法，使用2个指针分别扫描2个升序数组，比较大小移动2个指针，最终合并数组，参考的双指针算法

# 2022-08-21 08:41
### leetcode第 5 题
回文子串的定义：正读和反读都相同的字符序列为“回文”
<br>最长回文子串的关键是双指针扩散，找到以 s[i] 为中心的回文串。判断回文串的方法是找到距离left最远的和left相等的right，找到的同时left可以向左移动，right向右移动
<br>找回文串的关键技巧是传入两个指针 l 和 r 向两边扩散，因为这样实现可以同时处理回文串长度为奇数和偶数的情况。

### leetcode第 6 题
暂时没看懂，参考：https://zhuanlan.zhihu.com/p/79915327

### leetcode第 7 题
翻转整数的关键是%和/的运用，同时需要考虑到int的范围2147483647

### leetcode第 8 题
不属于常规Java算法题，暂时略过

### leetcode第 9 题
使用双指针，一左一右主意对比是否回文

### leetcode第 10 题
正则匹配使用到的动态规划过于复杂，后面继续研究

### leetcode第 11 题
类似于按横纵坐标计算容器最大水的情况，需要注意的一个是接水的容器是规则的，不倾斜，另一个就是使用双指针解决问题时，移动短边，因为移动长边是没有意义的，只会让容器越来越小，所以使用双指针从外向里计算一遍，更新最多大的值。

### leetcode第 12 题
从大到小，从左到右。同时每个数字本身也可能拆分，比如600=500+100，永远拆分一次，每个values只用一次，这样算起来的话。743 = 500 + 100 + 100 + 40 +3。内部记得使用while的，比如说80，那么就要计算2次，40+40

### leetcode第 13 题
罗马数字转换成数字的核心则是多算一位，即查询当前指针的下一个字母，如果发现是减的写法，则用后面一位的值减去这一位的值，然后索引额外加1，一次性处理了2个字母

# 2022-08-22 21:51
### leetcode第 14 题
计算最长公共前缀的核心在于数组的越界判断，比如数组只有一个值的情况，数组多个值里面有空或者都为空的情况

### leetcode第 15 题
2/3/4....N数之和，通过数组双指针和递归解决问题，一套公式秒杀所有N数之和的问题，这里的关键点在于递归，栈的最低层简化为2数之和，从而一层层出栈。递归方法的入参为：需要计算的数组、需要找出N个数值、当前的索引、目标值
<br>一个方法团灭 NSUM 问题：https://labuladong.github.io/algo/1/15/

# 2022-08-24 10:10
### leetcode第 16 题
N数之和是重点，由此可以延伸出最接近的三数之和，最接近的三数之和的核心是，从左到右遍历，以0 <= i < nums.length() - 2开始，每次遍历都找出i + 1 ~ nums.length()之间，距离目标值-当前i值最小的2个数字的值。再加上当前i的值，然后每次循环都更新这个最小的值
<br>一个方法团灭 NSUM 问题：https://labuladong.github.io/algo/1/15/

### leetcode第 17 题
电话号码的排列组合，使用回溯算法，其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，组合问题本质上就是遍历一棵回溯树，套用回溯算法代码框架即可。
<br>参考图片：https://labuladong.github.io/algo/images/backtracking/1.jpg
<br>回溯算法解题套路框架：https://labuladong.github.io/algo/1/8/

### leetcode第 18 题
参考leetcode15题，2/3/4....N数之和，通过数组双指针和递归解决问题，一套公式秒杀所有N数之和的问题，这里的关键点在于递归，栈的最低层简化为2数之和，从而一层层出栈。递归方法的入参为：需要计算的数组、需要找出N个数值、当前的索引、目标值
<br>一个方法团灭 NSUM 问题：https://labuladong.github.io/algo/1/15/

### leetcode第 19 题
要求一个链表的倒数第N个节点，需要用到快慢双指针方法，因为链表的长度的如果不遍历一遍的话是不知道的，通过N和双指针的快慢移动，能一次找到倒数第N个节点，它的逻辑是这样的，快指针先向后移动N个，慢指针不动，随后双指针同时移动，一直等到快指针到底，也就是NULL了，则这时候慢指针则倒了n-k的位置，即倒数第N个节点
<br>注意：快指针应该先走N+1，快慢一起走的时候慢指针先赋值，最终设置慢指针的下个节点等于原本的下下个节点，最终返回dummy的next节点，则是整个链表去除了倒数第N个节点

### leetcode第 20 题
判断括号是否闭合的关键是使用栈的数据结构，如果是左边的符号，则压入栈，如果是右边符号，则判断栈顶元素是否和他匹配，随后弹出右边符号
<br>注意：Stack.pop是弹出，peek是取值但是不弹出

# 2022-08-25 14:57
### leetcode第 21 题
合并2个有序链表的关键还是在于双指针和链表得的处理，老生常谈了。由于题目没有说明2个链表是一样的长度，而他们又经过排序了，所以只遍历到最短的长度，剩下的安心叠加到结果节点后面就行了
<br>注意：老规矩还是初始化一个虚拟节点dummy，然后用dummy.next去接住下面生成的真正的节点的头

### leetcode第 22 题
生成括号的问题使用回溯算法来题解，主要是先抽象出回溯的树，然后定义递归的参数，以及是否需要撤销选择，第17题就不需要撤销，长度到了就弹出了。括号问题的递归函数的参数定义为：左边括号剩余个数+右边括号剩余个数+当前树的路径生成的括号字符串
<br>递归函数内判断撤销选择的条件为：左边括号已经用掉的数量大于右边括号用掉的数量、没有剩余的括号数量了
<br>递归函数内压入栈的操作为：先压入左边括号，再压入右边括号，和函数对应，因为左边括号永远比右边括号多

### leetcode第 23 题
N多个链表的合并排序，这里的关键点在于使用优先级队列，也就是最小堆，将N个链表比如a1,b1,c1的头节点首先全部放入队列，随后定义一个虚拟节点，第一次判断得出他等于队列最小的b1，随后将b1拉到dummy的next，随后b1空出来了，如果还有b2，则填补上去，再次进入判断
<br>注意：dummy节点每次都要推进，即p=p.next，相当于初始化
<br>PriorityQueue Java（优先队列）参考文档：https://zhuanlan.zhihu.com/p/491698105

# 2022-08-26 05:43
### leetcode第 24 题
2个一组交换链表中的节点，核心还是在于递归，第1，2个节点排除在外等待递归出栈，最终结果是1指向1和2后面交换完成的子链表，2指向1。终止条件就是无法交换，为空，跳出递归
<br>疑问：这是碳基生物能想出来的逻辑？

### leetcode第 25 题
K个一组交换链表中的节点，核心还是在于递归，由小及大，终止条件是最后一组链表的长度小于k。先反转以 head 开头的 k 个元素。然后将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数。最后将上述两个过程的结果连接起来。
<br>一段n长度的链表的翻转参考：https://labuladong.github.io/algo/2/19/20/
<br>一段n长度的a-b的链表翻转：定义pre、cu、next。循环开始的标志是cu还在a-b链表之内，结束的标志是cu到了末尾了。翻转的逻辑是：next = cu.next,cu.next=pre,pre=cu,cu=next.最后返回pre

### leetcode第 26 题
升序排列 的数组 nums原地修改值，因为是升序排序过，所以核心还是在于快慢指针。快指针走在前，慢指针不动，如果快指针当前的值不等于慢指针所在位置的值，则把当前慢指针所在位置的值设置为快指针的值，然后慢指针移动，快指针继续向右。

### leetcode第 27 题
升序排列 的数组 nums原地修改值，因为是升序排序过，所以核心还是在于快慢指针。快指针走在前，慢指针不动，如果快指针当前的值不等于要删除的值，则把当前慢指针所在位置的值设置为快指针的值，然后慢指针移动，快指针继续向右。
<br>注意：27题和26题不一样，26题是先移动慢指针，再给慢指针赋值，27题是先赋值，再移动

### leetcode第 28 题
动态规划尚未学习到，暂时使用indexOf。实际上可以使用滑动窗口(l,r)，l和r分别代表子串的左右边界，初始化时候l在第一个位置，r在字符串的第r位置，如果不相等，则移动窗口两边指针同时向右，一直到匹配或者结束
<br>有限状态机之 KMP 字符匹配算法：https://labuladong.github.io/algo/3/28/97/

# 2022-08-28 08:02
### leetcode第 29 题
两数相除，不能用乘法和除法。
<br>方法一：定义被除数i，使用递归，将当前累计的值和总值传入，如果剩余值小于被除数，则结束

### leetcode第 30 题
查找子串的方法还是用滑动窗口，如果题目要求是多个单词，则用一个滑动窗口放多个单词，多个单词的顺序如果可变的话，则使用哈希值来判断。

### leetcode第 31 题
我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
<br>我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
<br>1.在尽可能靠右的低位进行交换，需要从后向前查找
<br>2.将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
<br>3.将「大数」换到前面后，需要将「大数」后面的所有数重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列
<br>代码总结下来就三步骤：
<br>1.使用指针i，从倒数第二位开始向前遍历，看一下相邻2个位置的数字大小，找到就停止
<br>2.使用指针j，从倒数第一位开始向前遍历，看一下i和j个位置的数字大小，如果i>j，则将i和j调换位置
<br>3.翻转i后面所有的值，得到下一个排列
<br>备注：数组调换位置的话，定义一个临时的值tmp等于nums[a]，然后nums[a] = nums[b], 最后nums[b] = tmp

# 2022-08-28 08:02
### leetcode第 32 题
单调栈解题模板秒杀三道算法题：https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487246&idx=1&sn=4a514020ce9dc8777e2d1d503188b62b&chksm=9bd7f106aca078108102fe76799983ee8ea3bd759508e6dbfe87bc9da6edbeb8b8dd73deb0d7&scene=178&cur_album_id=2121993002939219969#rd
<br>Stack.peek()，peek()函数返回栈顶的元素，但不弹出该栈顶元素。
<br>Stack.pop()，pop()函数返回栈顶的元素，并且将该栈顶元素出栈。
得到一个字符串的最长有效括号的核心代码：Stack<Integer> stk = new Stack<>();int[] dp = new int[s.length() + 1];
<br>碰到左边括号，则stk.push(i);dp[i + 1] = 0;
<br>碰到右边括号且没匹配到栈顶元素，则dp[i + 1] = 0;
<br>碰到右边括号且匹配到了栈顶元素，则int leftIndex = stk.pop();int len = 1 + i - leftIndex + dp[leftIndex]; dp[i + 1] = len;

### leetcode第 33 题
搜索旋转排列后的数组里面是否包含值，直接使用二分查找，分为2段。从2头开始查找，nums[i]和nums[numsSize - i - 1]是否等于目标值