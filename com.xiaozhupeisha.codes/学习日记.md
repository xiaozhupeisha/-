# 2022-08-18 21:21

### leetcode第 1 题
数组操作需要考虑边界值，特别是循环里面既判断左也判断右，混合continue、break的

### leetcode第 2 题
要输出计算出的新的链表的值，一般情况下来说，会新建一个新的虚拟节点，然后初始化一个指针，后续产生新的节点时候，则是跟着指针，也就是指针.next=新的节点1，指向完了之后需要记得将指针向后移动一格，也就是指针.next=新的节点2。最后完整的链表则是去除虚拟节点后的整个链表，也就是虚拟节点.next，返回一个头就可以了，虚拟节点后面自然跟着所有的链表的节点。

# 2022-08-20 09:47
### leetcode第 3 题
滑动窗口的灵魂是左闭右开，设置一个目标值，随着滑动窗口的移动，更新目标的值，比如说无重复的最长子串

### leetcode第 4 题
这道题是自己想的办法，使用2个指针分别扫描2个升序数组，比较大小移动2个指针，最终合并数组，参考的双指针算法

# 2022-08-21 08:41
### leetcode第 5 题
回文子串的定义：正读和反读都相同的字符序列为“回文”
最长回文子串的关键是双指针扩散，找到以 s[i] 为中心的回文串。判断回文串的方法是找到距离left最远的和left相等的right，找到的同时left可以向左移动，right向右移动
找回文串的关键技巧是传入两个指针 l 和 r 向两边扩散，因为这样实现可以同时处理回文串长度为奇数和偶数的情况。

### leetcode第 6 题
暂时没看懂，参考：https://zhuanlan.zhihu.com/p/79915327

### leetcode第 7 题
翻转整数的关键是%和/的运用，同时需要考虑到int的范围2147483647

### leetcode第 8 题
不属于常规Java算法题，暂时略过

### leetcode第 9 题
使用双指针，一左一右主意对比是否回文

### leetcode第 10 题
正则匹配使用到的动态规划过于复杂，后面继续研究

#### leetcode第 11 题
类似于按横纵坐标计算容器最大水的情况，需要注意的一个是接水的容器是规则的，不倾斜，另一个就是使用双指针解决问题时，移动短边，因为移动长边是没有意义的，只会让容器越来越小，所以使用双指针从外向里计算一遍，更新最多大的值。

##### leetcode第 12 题
从大到小，从左到右。同时每个数字本身也可能拆分，比如600=500+100，永远拆分一次，每个values只用一次，这样算起来的话。743 = 500 + 100 + 100 + 40 +3。内部记得使用while的，比如说80，那么就要计算2次，40+40

###### leetcode第 13 题
罗马数字转换成数字的核心则是多算一位，即查询当前指针的下一个字母，如果发现是减的写法，则用后面一位的值减去这一位的值，然后索引额外加1，一次性处理了2个字母